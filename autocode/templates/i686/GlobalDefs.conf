#--------------------------------------------------------------------
# Global Configuration file for use with projects using MemManager.h
#
# This file sets up the environment for autocoding but does not
# define any classes or subclasses. Each Class/Subclass must
# be defined in it's own file ___XXX__Defs.conf
#
# Any class who is accessed by an IDTYPE regardless of whether or
# not it is autocoded or uses a memManager MUST be declared here
#
#--------------------------------------------------------------------
# SYNTAX:
#
# Lines are comment lines, blank lines or definition lines. Comments and blank lines are ignored
# Comment lines start with #
# Lines containing Global config options start with '['
# Lines whihc define class types start with ']'
# Lines which indicate the start of a new class specific definition start with '|'
# Lines defining Class specific fields start with '~'
# ':' is used as a data separator
#
# We pack all the varibles into unsigned integers of the size specified with
# the glocal config option SIZE_OF_INT
# The order of the variables you input will be conserved. So make sure you pack things up
# correctly. Variables will not cross integer boundaries. When there is insufficient space
# in the current int to store the next variable then the remaining room will be wasted and
# the variable will start in the next int space. Pack wisely!!!
#
# SystemDefinedTypes:
#
# Currently we define 6 basic types:
# Pointer, Counter, Data, Variable Data and Flag
# The get and set methods will be different depending on which type
# for any particular definition
#
# MMG_POINTER   = needs to be check for consistency when in paranoid mode
# MMG_DATA      = needs to be shifted down before use and up after
# MMG_VAR_DATA  = like data but can span over multiple ints
# MMG_FLAG      = is a boolean so no shifting needed
# MMG_COUNTER   = uses get and increment instead of get and set
# MMG_S_COUNTER   = uses get and increment instead of get and set (for signed counters)
#
# The program can autogenerate get and set methods for the class if the autoconf field is set to 1
# otherwise it must be set to 0
# All autogenerated code is located in the file autocode.cpp and autocode.h
#
#--------------------------------------------------------------------
# Global config options.
# [:Name:Value:Comment
#--------------------------------------------------------------------
# These are mandatory:
# SIZE_OF_INT
# SIZE_OF_IDTYPE
#
#--------------------------------------------------------------------

[:SIZE_OF_INT:32:Set up for 32 bit integers
#[:SIZE_OF_INT:64:Set up for 64 bit integers

#
# <SIZE_OF_IDTYPE>
#
# If you change this value you MUST change the corresponding value
# in intdef.h
#

[:SIZE_OF_IDTYPE:32:Set up for 32 bit pointers
#[:SIZE_OF_IDTYPE:64:Set up for 64 bit pointers

#
# </SIZE_OF_IDTYPE>
#

#--------------------------------------------------------------------
# Class Definitions
# ]:MasterClassName:SubClassName:templated?:ClassID:Prefix:DeleteableMemManager:Autocode?:firstDivisor[,nextDivisor,...]:Comment
# you must list the name of any class which will be pointed to as a field
# of a memManager type object
# we will not use a memory manager when autocode == 0
#
# if the subclass name is the same as the masterclass name AND autocode == 1
# then the resizing varibles will be used.
# resizing looks like this: x[,y,z,...,l]
# the original number of containers to be allocated 'O'is given at runtime.
# When this is full the memManager will allocate another O/x containers and
# then another O/y when these are full and so on
# the last divisor 'l' is stored and all subsequent allocations are of size O/l
# you MUST supply at least one divisor
#--------------------------------------------------------------------

# generic storage for sequences
]:ReadStore:ReadStore:1:MMG_P_RS:RS_:0:1:8:Used to store reads for the ReadStore Class

# overlap graph
]:UniNode:UniNode:1:MMG_P_UN:UN_:0:1:4,4,8:Used to store base info for the UniNode Class
]:UniNode:UniNodeData:1:MMG_P_UND:UND_:0:1:0:Used to store overlaps for the UniNode Class

# mapping between sequences in overlap graph and kmers
]:KmerMap:KmerMap:0:MMG_P_KM:KM_:1:1:4,4,8:Used to map kmers to nodes which contain them
]:KmerMap:KmerMapData:0:MMG_P_KMD:KMD_:1:1:0:Data Blocks for the kmer map

]:KmerMatchMap:KmerMatchMap:0:MMG_P_KMM:KMM_:1:1:1:Used to store information about how nodes should be joined wrt their kmers
]:KmerMatchMap:KmerMatchMapData:0:MMG_P_KMMD:KMMD_:1:1:0:Used to store information about how nodes should be joined wrt their kmers

# overlap-pair graph
]:DualNode:DualNode:0:MMG_P_DN:DN_:1:1:4,4,8:Used to store base info for the DualNode Class
]:DualNode:DualNodeData:0:MMG_P_DND:DND_:1:1:0:Used to store overlaps for the DualNode Class

# mapping between nodes in overlap graph and overlap-pair graph
]:GenericNode:GenericNode:0:MMG_P_GN:GN_:1:1:4,4,8:Generic node element for interfacing with contig objects

# contig storage
]:Contig:Contig:0:MMG_P_CTG:CTG_:0:1:2:Holder for Generic contigs

# contexts
]:Context:Context:0:MMG_P_CTX:CTX_:1:1:2:Holder for Context objects

# mapping between generic nodes and context positions
]:NodePositionMap:NodePositionMap:0:MMG_P_NPM:NPM_:1:1:2:Maps generic nodes to positions in the context

# mapping between generic nodes and context positions
]:NodeCheck:NodeCheck:0:MMG_P_NC:NC_:1:1:4:Stops nodes from dissapearing

# storing read ids in a tight format
]:ReadIdentifier:ReadIdentifier:0:MMG_P_RID:RID_:1:1:4:Stores the read ID
